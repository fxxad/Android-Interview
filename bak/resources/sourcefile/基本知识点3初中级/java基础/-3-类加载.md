#### 必知

* **启动（Bootstrap）类加载器**：引导类加载器是用 **本地代码实现的类加载器**，它负责将 **<JAVA_HOME>/lib下面的核心类库** 或 **-Xbootclasspath选项指定的jar包等** **虚拟机识别的类库**加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以 **不允许直接通过引用进行操作**
* **扩展（Extension）类加载器**：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将<**JAVA_HOME>/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库**加载到内存中。**开发者可以直接使用标准扩展类加载器。**
* **系统（System）类加载器**：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，它负责将 **用户类路径(java-classpath或-Djava.class.path变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，如第四节中的问题6所述)下的类库** 加载到内存中。**开发者可以直接使用系统类加载器。**
* 类加载双亲委派机制：**JVM在加载类时默认采用的是双亲委派机制**。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，**依次递归 (本质上就是loadClass函数的递归调用)**。因此，**所有的加载请求最终都应该传送到顶层的启动类加载器中**。如果父类加载器可以完成这个类加载请求，就成功返回；只有当父类加载器无法完成此加载请求时，子加载器才会尝试自己去加载。**事实上，大多数情况下，越基础的类由越上层的加载器进行加载，因为这些基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API（当然，也存在基础类回调用户用户代码的情形）。**

#### 必会

jvm 虚拟机默认使用三个雷加载器：启动（Bootstrap）类加载器、扩展（Extension）类加载器和系统（System）类加载器。类加载采用双亲委派机制，顶级父类最先加载类，如果父类不能加载，再由子类去加载。

###### 参考文章

[深入理解Java类加载器(一)：Java类加载原理解析](http://blog.csdn.net/justloveyou_/article/details/72217806)